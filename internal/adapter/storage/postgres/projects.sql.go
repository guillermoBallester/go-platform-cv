// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: projects.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addSkillToProject = `-- name: AddSkillToProject :exec
INSERT INTO project_skills (project_id, skill_id) VALUES ($1, $2) ON CONFLICT DO NOTHING
`

type AddSkillToProjectParams struct {
	ProjectID int32 `json:"project_id"`
	SkillID   int32 `json:"skill_id"`
}

// Skill linking
func (q *Queries) AddSkillToProject(ctx context.Context, arg AddSkillToProjectParams) error {
	_, err := q.db.Exec(ctx, addSkillToProject, arg.ProjectID, arg.SkillID)
	return err
}

const createProject = `-- name: CreateProject :one
INSERT INTO projects (name, description, start_date, end_date)
VALUES ($1, $2, $3, $4)
RETURNING id, name, description, start_date, end_date, created_at, updated_at
`

type CreateProjectParams struct {
	Name        string      `json:"name"`
	Description string      `json:"description"`
	StartDate   pgtype.Date `json:"start_date"`
	EndDate     pgtype.Date `json:"end_date"`
}

func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, createProject,
		arg.Name,
		arg.Description,
		arg.StartDate,
		arg.EndDate,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.StartDate,
		&i.EndDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteProject = `-- name: DeleteProject :exec
DELETE FROM projects WHERE id = $1
`

func (q *Queries) DeleteProject(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteProject, id)
	return err
}

const getProject = `-- name: GetProject :one
SELECT id, name, description, start_date, end_date, created_at, updated_at FROM projects WHERE id = $1
`

func (q *Queries) GetProject(ctx context.Context, id int32) (Project, error) {
	row := q.db.QueryRow(ctx, getProject, id)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.StartDate,
		&i.EndDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProjectWithSkills = `-- name: GetProjectWithSkills :many
SELECT
    p.id, p.name, p.description, p.start_date, p.end_date,
    p.created_at, p.updated_at,
    s.id as skill_id, s.name as skill_name, s.category as skill_category
FROM projects p
LEFT JOIN project_skills ps ON p.id = ps.project_id
LEFT JOIN skills s ON ps.skill_id = s.id
WHERE p.id = $1
ORDER BY s.category, s.name
`

type GetProjectWithSkillsRow struct {
	ID            int32              `json:"id"`
	Name          string             `json:"name"`
	Description   string             `json:"description"`
	StartDate     pgtype.Date        `json:"start_date"`
	EndDate       pgtype.Date        `json:"end_date"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
	SkillID       pgtype.Int4        `json:"skill_id"`
	SkillName     pgtype.Text        `json:"skill_name"`
	SkillCategory pgtype.Text        `json:"skill_category"`
}

// Full project with skills (for display/RAG)
func (q *Queries) GetProjectWithSkills(ctx context.Context, id int32) ([]GetProjectWithSkillsRow, error) {
	rows, err := q.db.Query(ctx, getProjectWithSkills, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProjectWithSkillsRow
	for rows.Next() {
		var i GetProjectWithSkillsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.StartDate,
			&i.EndDate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SkillID,
			&i.SkillName,
			&i.SkillCategory,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listExperiencesForProject = `-- name: ListExperiencesForProject :many
SELECT e.id, e.company_name, e.job_title, e.location, e.start_date, e.end_date, e.description, e.highlights, e.created_at, e.updated_at FROM experiences e
JOIN experience_projects ep ON e.id = ep.experience_id
WHERE ep.project_id = $1
ORDER BY e.start_date DESC
`

// Experience linking
func (q *Queries) ListExperiencesForProject(ctx context.Context, projectID int32) ([]Experience, error) {
	rows, err := q.db.Query(ctx, listExperiencesForProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Experience
	for rows.Next() {
		var i Experience
		if err := rows.Scan(
			&i.ID,
			&i.CompanyName,
			&i.JobTitle,
			&i.Location,
			&i.StartDate,
			&i.EndDate,
			&i.Description,
			&i.Highlights,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjects = `-- name: ListProjects :many
SELECT id, name, description, start_date, end_date, created_at, updated_at FROM projects ORDER BY start_date DESC NULLS LAST
`

func (q *Queries) ListProjects(ctx context.Context) ([]Project, error) {
	rows, err := q.db.Query(ctx, listProjects)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.StartDate,
			&i.EndDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectsForSkill = `-- name: ListProjectsForSkill :many
SELECT p.id, p.name, p.description, p.start_date, p.end_date, p.created_at, p.updated_at FROM projects p
JOIN project_skills ps ON p.id = ps.project_id
WHERE ps.skill_id = $1
ORDER BY p.start_date DESC NULLS LAST
`

func (q *Queries) ListProjectsForSkill(ctx context.Context, skillID int32) ([]Project, error) {
	rows, err := q.db.Query(ctx, listProjectsForSkill, skillID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.StartDate,
			&i.EndDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSkillsForProject = `-- name: ListSkillsForProject :many
SELECT s.id, s.name, s.category, s.proficiency, s.logo_url FROM skills s
JOIN project_skills ps ON s.id = ps.skill_id
WHERE ps.project_id = $1
ORDER BY s.category, s.name
`

func (q *Queries) ListSkillsForProject(ctx context.Context, projectID int32) ([]Skill, error) {
	rows, err := q.db.Query(ctx, listSkillsForProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Skill
	for rows.Next() {
		var i Skill
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Category,
			&i.Proficiency,
			&i.LogoUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeSkillFromProject = `-- name: RemoveSkillFromProject :exec
DELETE FROM project_skills WHERE project_id = $1 AND skill_id = $2
`

type RemoveSkillFromProjectParams struct {
	ProjectID int32 `json:"project_id"`
	SkillID   int32 `json:"skill_id"`
}

func (q *Queries) RemoveSkillFromProject(ctx context.Context, arg RemoveSkillFromProjectParams) error {
	_, err := q.db.Exec(ctx, removeSkillFromProject, arg.ProjectID, arg.SkillID)
	return err
}

const updateProject = `-- name: UpdateProject :one
UPDATE projects
SET name = $2, description = $3, start_date = $4, end_date = $5, updated_at = NOW()
WHERE id = $1
RETURNING id, name, description, start_date, end_date, created_at, updated_at
`

type UpdateProjectParams struct {
	ID          int32       `json:"id"`
	Name        string      `json:"name"`
	Description string      `json:"description"`
	StartDate   pgtype.Date `json:"start_date"`
	EndDate     pgtype.Date `json:"end_date"`
}

func (q *Queries) UpdateProject(ctx context.Context, arg UpdateProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, updateProject,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.StartDate,
		arg.EndDate,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.StartDate,
		&i.EndDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
