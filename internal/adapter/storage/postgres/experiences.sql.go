// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: experiences.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addProjectToExperience = `-- name: AddProjectToExperience :exec
INSERT INTO experience_projects (experience_id, project_id) VALUES ($1, $2) ON CONFLICT DO NOTHING
`

type AddProjectToExperienceParams struct {
	ExperienceID int32 `json:"experience_id"`
	ProjectID    int32 `json:"project_id"`
}

// Project linking
func (q *Queries) AddProjectToExperience(ctx context.Context, arg AddProjectToExperienceParams) error {
	_, err := q.db.Exec(ctx, addProjectToExperience, arg.ExperienceID, arg.ProjectID)
	return err
}

const addSkillToExperience = `-- name: AddSkillToExperience :exec
INSERT INTO experience_skills (experience_id, skill_id) VALUES ($1, $2) ON CONFLICT DO NOTHING
`

type AddSkillToExperienceParams struct {
	ExperienceID int32 `json:"experience_id"`
	SkillID      int32 `json:"skill_id"`
}

// Skill linking
func (q *Queries) AddSkillToExperience(ctx context.Context, arg AddSkillToExperienceParams) error {
	_, err := q.db.Exec(ctx, addSkillToExperience, arg.ExperienceID, arg.SkillID)
	return err
}

const createExperience = `-- name: CreateExperience :one
INSERT INTO experiences (company_name, job_title, location, start_date, end_date, description, highlights)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, company_name, job_title, location, start_date, end_date, description, highlights, created_at, updated_at
`

type CreateExperienceParams struct {
	CompanyName string      `json:"company_name"`
	JobTitle    string      `json:"job_title"`
	Location    pgtype.Text `json:"location"`
	StartDate   pgtype.Date `json:"start_date"`
	EndDate     pgtype.Date `json:"end_date"`
	Description string      `json:"description"`
	Highlights  pgtype.Text `json:"highlights"`
}

func (q *Queries) CreateExperience(ctx context.Context, arg CreateExperienceParams) (Experience, error) {
	row := q.db.QueryRow(ctx, createExperience,
		arg.CompanyName,
		arg.JobTitle,
		arg.Location,
		arg.StartDate,
		arg.EndDate,
		arg.Description,
		arg.Highlights,
	)
	var i Experience
	err := row.Scan(
		&i.ID,
		&i.CompanyName,
		&i.JobTitle,
		&i.Location,
		&i.StartDate,
		&i.EndDate,
		&i.Description,
		&i.Highlights,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteExperience = `-- name: DeleteExperience :exec
DELETE FROM experiences WHERE id = $1
`

func (q *Queries) DeleteExperience(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteExperience, id)
	return err
}

const getExperience = `-- name: GetExperience :one
SELECT id, company_name, job_title, location, start_date, end_date, description, highlights, created_at, updated_at FROM experiences WHERE id = $1
`

func (q *Queries) GetExperience(ctx context.Context, id int32) (Experience, error) {
	row := q.db.QueryRow(ctx, getExperience, id)
	var i Experience
	err := row.Scan(
		&i.ID,
		&i.CompanyName,
		&i.JobTitle,
		&i.Location,
		&i.StartDate,
		&i.EndDate,
		&i.Description,
		&i.Highlights,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getExperienceWithSkills = `-- name: GetExperienceWithSkills :many
SELECT
    e.id, e.company_name, e.job_title, e.location, e.start_date, e.end_date,
    e.description, e.highlights, e.created_at, e.updated_at,
    s.id as skill_id, s.name as skill_name, s.category as skill_category
FROM experiences e
LEFT JOIN experience_skills es ON e.id = es.experience_id
LEFT JOIN skills s ON es.skill_id = s.id
WHERE e.id = $1
ORDER BY s.category, s.name
`

type GetExperienceWithSkillsRow struct {
	ID            int32              `json:"id"`
	CompanyName   string             `json:"company_name"`
	JobTitle      string             `json:"job_title"`
	Location      pgtype.Text        `json:"location"`
	StartDate     pgtype.Date        `json:"start_date"`
	EndDate       pgtype.Date        `json:"end_date"`
	Description   string             `json:"description"`
	Highlights    pgtype.Text        `json:"highlights"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
	SkillID       pgtype.Int4        `json:"skill_id"`
	SkillName     pgtype.Text        `json:"skill_name"`
	SkillCategory pgtype.Text        `json:"skill_category"`
}

// Full experience with skills (for display/RAG)
func (q *Queries) GetExperienceWithSkills(ctx context.Context, id int32) ([]GetExperienceWithSkillsRow, error) {
	rows, err := q.db.Query(ctx, getExperienceWithSkills, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExperienceWithSkillsRow
	for rows.Next() {
		var i GetExperienceWithSkillsRow
		if err := rows.Scan(
			&i.ID,
			&i.CompanyName,
			&i.JobTitle,
			&i.Location,
			&i.StartDate,
			&i.EndDate,
			&i.Description,
			&i.Highlights,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SkillID,
			&i.SkillName,
			&i.SkillCategory,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listExperiences = `-- name: ListExperiences :many
SELECT id, company_name, job_title, location, start_date, end_date, description, highlights, created_at, updated_at FROM experiences ORDER BY start_date DESC
`

func (q *Queries) ListExperiences(ctx context.Context) ([]Experience, error) {
	rows, err := q.db.Query(ctx, listExperiences)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Experience
	for rows.Next() {
		var i Experience
		if err := rows.Scan(
			&i.ID,
			&i.CompanyName,
			&i.JobTitle,
			&i.Location,
			&i.StartDate,
			&i.EndDate,
			&i.Description,
			&i.Highlights,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listExperiencesForSkill = `-- name: ListExperiencesForSkill :many
SELECT e.id, e.company_name, e.job_title, e.location, e.start_date, e.end_date, e.description, e.highlights, e.created_at, e.updated_at FROM experiences e
JOIN experience_skills es ON e.id = es.experience_id
WHERE es.skill_id = $1
ORDER BY e.start_date DESC
`

func (q *Queries) ListExperiencesForSkill(ctx context.Context, skillID int32) ([]Experience, error) {
	rows, err := q.db.Query(ctx, listExperiencesForSkill, skillID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Experience
	for rows.Next() {
		var i Experience
		if err := rows.Scan(
			&i.ID,
			&i.CompanyName,
			&i.JobTitle,
			&i.Location,
			&i.StartDate,
			&i.EndDate,
			&i.Description,
			&i.Highlights,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectsForExperience = `-- name: ListProjectsForExperience :many
SELECT p.id, p.name, p.description, p.start_date, p.end_date, p.created_at, p.updated_at FROM projects p
JOIN experience_projects ep ON p.id = ep.project_id
WHERE ep.experience_id = $1
ORDER BY p.start_date DESC
`

func (q *Queries) ListProjectsForExperience(ctx context.Context, experienceID int32) ([]Project, error) {
	rows, err := q.db.Query(ctx, listProjectsForExperience, experienceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.StartDate,
			&i.EndDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSkillsForExperience = `-- name: ListSkillsForExperience :many
SELECT s.id, s.name, s.category, s.proficiency, s.logo_url FROM skills s
JOIN experience_skills es ON s.id = es.skill_id
WHERE es.experience_id = $1
ORDER BY s.category, s.name
`

func (q *Queries) ListSkillsForExperience(ctx context.Context, experienceID int32) ([]Skill, error) {
	rows, err := q.db.Query(ctx, listSkillsForExperience, experienceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Skill
	for rows.Next() {
		var i Skill
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Category,
			&i.Proficiency,
			&i.LogoUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeProjectFromExperience = `-- name: RemoveProjectFromExperience :exec
DELETE FROM experience_projects WHERE experience_id = $1 AND project_id = $2
`

type RemoveProjectFromExperienceParams struct {
	ExperienceID int32 `json:"experience_id"`
	ProjectID    int32 `json:"project_id"`
}

func (q *Queries) RemoveProjectFromExperience(ctx context.Context, arg RemoveProjectFromExperienceParams) error {
	_, err := q.db.Exec(ctx, removeProjectFromExperience, arg.ExperienceID, arg.ProjectID)
	return err
}

const removeSkillFromExperience = `-- name: RemoveSkillFromExperience :exec
DELETE FROM experience_skills WHERE experience_id = $1 AND skill_id = $2
`

type RemoveSkillFromExperienceParams struct {
	ExperienceID int32 `json:"experience_id"`
	SkillID      int32 `json:"skill_id"`
}

func (q *Queries) RemoveSkillFromExperience(ctx context.Context, arg RemoveSkillFromExperienceParams) error {
	_, err := q.db.Exec(ctx, removeSkillFromExperience, arg.ExperienceID, arg.SkillID)
	return err
}

const updateExperience = `-- name: UpdateExperience :one
UPDATE experiences
SET company_name = $2, job_title = $3, location = $4, start_date = $5, end_date = $6,
    description = $7, highlights = $8, updated_at = NOW()
WHERE id = $1
RETURNING id, company_name, job_title, location, start_date, end_date, description, highlights, created_at, updated_at
`

type UpdateExperienceParams struct {
	ID          int32       `json:"id"`
	CompanyName string      `json:"company_name"`
	JobTitle    string      `json:"job_title"`
	Location    pgtype.Text `json:"location"`
	StartDate   pgtype.Date `json:"start_date"`
	EndDate     pgtype.Date `json:"end_date"`
	Description string      `json:"description"`
	Highlights  pgtype.Text `json:"highlights"`
}

func (q *Queries) UpdateExperience(ctx context.Context, arg UpdateExperienceParams) (Experience, error) {
	row := q.db.QueryRow(ctx, updateExperience,
		arg.ID,
		arg.CompanyName,
		arg.JobTitle,
		arg.Location,
		arg.StartDate,
		arg.EndDate,
		arg.Description,
		arg.Highlights,
	)
	var i Experience
	err := row.Scan(
		&i.ID,
		&i.CompanyName,
		&i.JobTitle,
		&i.Location,
		&i.StartDate,
		&i.EndDate,
		&i.Description,
		&i.Highlights,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
