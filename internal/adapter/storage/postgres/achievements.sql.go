// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: achievements.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addSkillToAchievement = `-- name: AddSkillToAchievement :exec
INSERT INTO achievement_skills (achievement_id, skill_id) VALUES ($1, $2) ON CONFLICT DO NOTHING
`

type AddSkillToAchievementParams struct {
	AchievementID int32 `json:"achievement_id"`
	SkillID       int32 `json:"skill_id"`
}

// Skill linking
func (q *Queries) AddSkillToAchievement(ctx context.Context, arg AddSkillToAchievementParams) error {
	_, err := q.db.Exec(ctx, addSkillToAchievement, arg.AchievementID, arg.SkillID)
	return err
}

const clearSkillsFromAchievement = `-- name: ClearSkillsFromAchievement :exec
DELETE FROM achievement_skills WHERE achievement_id = $1
`

func (q *Queries) ClearSkillsFromAchievement(ctx context.Context, achievementID int32) error {
	_, err := q.db.Exec(ctx, clearSkillsFromAchievement, achievementID)
	return err
}

const createAchievement = `-- name: CreateAchievement :one
INSERT INTO achievements (title, description, date, experience_id, project_id)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, title, description, date, experience_id, project_id, created_at, updated_at
`

type CreateAchievementParams struct {
	Title        string      `json:"title"`
	Description  string      `json:"description"`
	Date         pgtype.Date `json:"date"`
	ExperienceID pgtype.Int4 `json:"experience_id"`
	ProjectID    pgtype.Int4 `json:"project_id"`
}

func (q *Queries) CreateAchievement(ctx context.Context, arg CreateAchievementParams) (Achievement, error) {
	row := q.db.QueryRow(ctx, createAchievement,
		arg.Title,
		arg.Description,
		arg.Date,
		arg.ExperienceID,
		arg.ProjectID,
	)
	var i Achievement
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Date,
		&i.ExperienceID,
		&i.ProjectID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAchievement = `-- name: DeleteAchievement :exec
DELETE FROM achievements WHERE id = $1
`

func (q *Queries) DeleteAchievement(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteAchievement, id)
	return err
}

const getAchievement = `-- name: GetAchievement :one
SELECT id, title, description, date, experience_id, project_id, created_at, updated_at FROM achievements WHERE id = $1
`

func (q *Queries) GetAchievement(ctx context.Context, id int32) (Achievement, error) {
	row := q.db.QueryRow(ctx, getAchievement, id)
	var i Achievement
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Date,
		&i.ExperienceID,
		&i.ProjectID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAchievementByTitle = `-- name: GetAchievementByTitle :one
SELECT id, title, description, date, experience_id, project_id, created_at, updated_at FROM achievements WHERE title = $1
`

func (q *Queries) GetAchievementByTitle(ctx context.Context, title string) (Achievement, error) {
	row := q.db.QueryRow(ctx, getAchievementByTitle, title)
	var i Achievement
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Date,
		&i.ExperienceID,
		&i.ProjectID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAchievementWithSkills = `-- name: GetAchievementWithSkills :many
SELECT
    a.id, a.title, a.description, a.date, a.experience_id, a.project_id,
    a.created_at, a.updated_at,
    s.id as skill_id, s.name as skill_name, s.category as skill_category
FROM achievements a
LEFT JOIN achievement_skills aks ON a.id = aks.achievement_id
LEFT JOIN skills s ON aks.skill_id = s.id
WHERE a.id = $1
ORDER BY s.category, s.name
`

type GetAchievementWithSkillsRow struct {
	ID            int32              `json:"id"`
	Title         string             `json:"title"`
	Description   string             `json:"description"`
	Date          pgtype.Date        `json:"date"`
	ExperienceID  pgtype.Int4        `json:"experience_id"`
	ProjectID     pgtype.Int4        `json:"project_id"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
	SkillID       pgtype.Int4        `json:"skill_id"`
	SkillName     pgtype.Text        `json:"skill_name"`
	SkillCategory pgtype.Text        `json:"skill_category"`
}

// Full achievement with skills (for display/RAG)
func (q *Queries) GetAchievementWithSkills(ctx context.Context, id int32) ([]GetAchievementWithSkillsRow, error) {
	rows, err := q.db.Query(ctx, getAchievementWithSkills, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAchievementWithSkillsRow
	for rows.Next() {
		var i GetAchievementWithSkillsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Date,
			&i.ExperienceID,
			&i.ProjectID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SkillID,
			&i.SkillName,
			&i.SkillCategory,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAchievements = `-- name: ListAchievements :many
SELECT id, title, description, date, experience_id, project_id, created_at, updated_at FROM achievements ORDER BY date DESC NULLS LAST
`

func (q *Queries) ListAchievements(ctx context.Context) ([]Achievement, error) {
	rows, err := q.db.Query(ctx, listAchievements)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Achievement
	for rows.Next() {
		var i Achievement
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Date,
			&i.ExperienceID,
			&i.ProjectID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAchievementsForExperience = `-- name: ListAchievementsForExperience :many
SELECT id, title, description, date, experience_id, project_id, created_at, updated_at FROM achievements WHERE experience_id = $1 ORDER BY date DESC NULLS LAST
`

// Filter by context
func (q *Queries) ListAchievementsForExperience(ctx context.Context, experienceID pgtype.Int4) ([]Achievement, error) {
	rows, err := q.db.Query(ctx, listAchievementsForExperience, experienceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Achievement
	for rows.Next() {
		var i Achievement
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Date,
			&i.ExperienceID,
			&i.ProjectID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAchievementsForProject = `-- name: ListAchievementsForProject :many
SELECT id, title, description, date, experience_id, project_id, created_at, updated_at FROM achievements WHERE project_id = $1 ORDER BY date DESC NULLS LAST
`

func (q *Queries) ListAchievementsForProject(ctx context.Context, projectID pgtype.Int4) ([]Achievement, error) {
	rows, err := q.db.Query(ctx, listAchievementsForProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Achievement
	for rows.Next() {
		var i Achievement
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Date,
			&i.ExperienceID,
			&i.ProjectID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAchievementsForSkill = `-- name: ListAchievementsForSkill :many
SELECT a.id, a.title, a.description, a.date, a.experience_id, a.project_id, a.created_at, a.updated_at FROM achievements a
JOIN achievement_skills aks ON a.id = aks.achievement_id
WHERE aks.skill_id = $1
ORDER BY a.date DESC NULLS LAST
`

func (q *Queries) ListAchievementsForSkill(ctx context.Context, skillID int32) ([]Achievement, error) {
	rows, err := q.db.Query(ctx, listAchievementsForSkill, skillID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Achievement
	for rows.Next() {
		var i Achievement
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Date,
			&i.ExperienceID,
			&i.ProjectID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAchievementsWithContext = `-- name: ListAchievementsWithContext :many
SELECT
    a.id, a.title, a.description, a.date,
    e.company_name, e.job_title,
    p.name as project_name
FROM achievements a
LEFT JOIN experiences e ON a.experience_id = e.id
LEFT JOIN projects p ON a.project_id = p.id
ORDER BY a.date DESC NULLS LAST
`

type ListAchievementsWithContextRow struct {
	ID          int32       `json:"id"`
	Title       string      `json:"title"`
	Description string      `json:"description"`
	Date        pgtype.Date `json:"date"`
	CompanyName pgtype.Text `json:"company_name"`
	JobTitle    pgtype.Text `json:"job_title"`
	ProjectName pgtype.Text `json:"project_name"`
}

// RAG context query: Get all achievements with their related experience/project context
func (q *Queries) ListAchievementsWithContext(ctx context.Context) ([]ListAchievementsWithContextRow, error) {
	rows, err := q.db.Query(ctx, listAchievementsWithContext)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAchievementsWithContextRow
	for rows.Next() {
		var i ListAchievementsWithContextRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Date,
			&i.CompanyName,
			&i.JobTitle,
			&i.ProjectName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSkillsForAchievement = `-- name: ListSkillsForAchievement :many
SELECT s.id, s.name, s.category, s.proficiency, s.logo_url FROM skills s
JOIN achievement_skills aks ON s.id = aks.skill_id
WHERE aks.achievement_id = $1
ORDER BY s.category, s.name
`

func (q *Queries) ListSkillsForAchievement(ctx context.Context, achievementID int32) ([]Skill, error) {
	rows, err := q.db.Query(ctx, listSkillsForAchievement, achievementID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Skill
	for rows.Next() {
		var i Skill
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Category,
			&i.Proficiency,
			&i.LogoUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeSkillFromAchievement = `-- name: RemoveSkillFromAchievement :exec
DELETE FROM achievement_skills WHERE achievement_id = $1 AND skill_id = $2
`

type RemoveSkillFromAchievementParams struct {
	AchievementID int32 `json:"achievement_id"`
	SkillID       int32 `json:"skill_id"`
}

func (q *Queries) RemoveSkillFromAchievement(ctx context.Context, arg RemoveSkillFromAchievementParams) error {
	_, err := q.db.Exec(ctx, removeSkillFromAchievement, arg.AchievementID, arg.SkillID)
	return err
}

const updateAchievement = `-- name: UpdateAchievement :one
UPDATE achievements
SET title = $2, description = $3, date = $4, experience_id = $5,
    project_id = $6, updated_at = NOW()
WHERE id = $1
RETURNING id, title, description, date, experience_id, project_id, created_at, updated_at
`

type UpdateAchievementParams struct {
	ID           int32       `json:"id"`
	Title        string      `json:"title"`
	Description  string      `json:"description"`
	Date         pgtype.Date `json:"date"`
	ExperienceID pgtype.Int4 `json:"experience_id"`
	ProjectID    pgtype.Int4 `json:"project_id"`
}

func (q *Queries) UpdateAchievement(ctx context.Context, arg UpdateAchievementParams) (Achievement, error) {
	row := q.db.QueryRow(ctx, updateAchievement,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.Date,
		arg.ExperienceID,
		arg.ProjectID,
	)
	var i Achievement
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Date,
		&i.ExperienceID,
		&i.ProjectID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
